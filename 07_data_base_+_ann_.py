# -*- coding: utf-8 -*-
"""07 - Data Base + ANN .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17on42sePv_7p3gqqA-diVN7mt732PHIi

Importamos las librerias para crear la base de datos.
"""

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import random as rd
import tensorflow as tf

"""Creamos la base de datos con funciones"""

#plt.style.use("dark_background")

"""
    Cantidad_datos: INT
        Cuantos datos se le da a la base de datos

    Parameters
    ----------
    Cantidad_datos : INT
        NÚMERO DE DATOS QUE SE LE DA A LA BASE DE DATOS.

    Returns
    -------
    CSV.
"""

def u(t):
    """
    Definición de la función escalar unitaria.

    :param t:
    :return: 0 x 1
    """
    return np.piecewise(t, [t < 0.0, t >= 0.0], [0, 1])

def normal (cantidad_datos,time=False):
    """
    Genera ondas sin ningun problema a 60 Hz

    """
    x_n=[]
    t = np.linspace(0, 1/6, int(1/6*2000))
#   ///////datos necesarios para el df/////

    # guardamos los datos en el df
    for i in range (0, cantidad_datos):
        # caracteristicas sag y de la onda
        desfase = rd.uniform (0, 2*np.pi) #desfase de la onda

        #resultado: onda con sag y guardamos en el dict
        f_n = np.sin(2*np.pi*60*t+desfase)
        x_n.append(list(f_n))
    # Se guarda el dict como la base de datos, primera columna es el vector t

    # Exportamos csv
    if time==False:
      return x_n
    else:
      return x_n , list(t)
def swell_harmonic (cantidad_datos,time=False):
    """
    Generamos Swell con armonicos

    """
    x_hsw=[]
    t = np.linspace(0, 1/6, int(1/6*2000))
#   ///////datos necesarios para el df/////

    for i in range (0, cantidad_datos):
        alpha = rd.uniform(0.1, 0.8) #amplitud del swell norma IEEE
        duracion = rd.uniform(1/60, 1/5)
        t_1 = rd.uniform(0, 1/7.5-duracion)
        t_2 = t_1+duracion # el valor final depende de la duración

        des=rd.uniform (0, 2*np.pi)
        alpha3=rd.uniform (0.1,0.02)
        des3=rd.uniform (0, 2*np.pi)
        alpha5=rd.uniform (0.1,0.02)
        des5=rd.uniform (0, 2*np.pi)
        alpha7=rd.uniform (0.1,0.02)
        des7=rd.uniform (0, 2*np.pi)
        #resultado: onda con sag y guardamos en el dict
        f_hsw =  (1+alpha*(u(t-t_1)-u(t-t_2)))*(np.sin(2*np.pi*60*t+des)+alpha3*np.sin(2*np.pi*60*t*3+des3)+alpha5*np.sin(2*np.pi*60*t*5+des5)+alpha7*np.sin(2*np.pi*60*t*7+des7))
        x_hsw.append(list(f_hsw))

    if time==False:
      return x_hsw
    else:
      return x_hsw , list(t)

def swell (cantidad_datos,time=False):
    """
    Generamos Swell

    """
    x_sw=[]
    t = np.linspace(0, 1/6, int(1/6*2000))
#   ///////datos necesarios para el df/////
    # guardamos los datos en el df
    for i in range (0, cantidad_datos):
        # caracteristicas sag y de la onda
        alpha = rd.uniform(0.1, 0.8) #amplitud del swell norma IEEE
        duracion = rd.uniform(1/60, 1/5) # cuánto dura el fenómeno en segundos
        t_1 = rd.uniform(0, 1/7.5-duracion)
        t_2 = t_1+duracion # el valor final depende de la duración
        desfase = rd.uniform (0, 2*np.pi) #desfase de la onda

        #resultado: onda con sag y guardamos en el dict
        f_sw = (1+alpha*(u(t-t_1)-u(t-t_2)))*np.sin(2*np.pi*60*t+desfase)

        x_sw.append(list(f_sw))

    if time==False:
      return x_sw
    else:
      return x_sw , list(t)

def interruption_harmonic(cantidad_datos,time=False):
    """
    Generamos una interrupcion con armonicos

    """
    x_ih=[]
    t = np.linspace(0, 1/6, int(1/6*2000))

    for i in range (0, cantidad_datos):
        alpha = rd.uniform(0.9,1) #amplitud del sag norma IEEE
        duracion = rd.uniform(1/60, 1/5)
        t_1 = rd.uniform(0, 1/7.5-duracion)
        t_2 = t_1+duracion # el valor final depende de la duración

        des=rd.uniform (0, 2*np.pi)
        alpha3=rd.uniform (0.1,0.02)
        des3=rd.uniform (0, 2*np.pi)
        alpha5=rd.uniform (0.1,0.02)
        des5=rd.uniform (0, 2*np.pi)
        alpha7=rd.uniform (0.1,0.02)
        des7=rd.uniform (0, 2*np.pi)
        #resultado: onda con sag y guardamos en el dict
        f_ih =  (1-alpha*(u(t-t_1)-u(t-t_2)))*(np.sin(2*np.pi*60*t+des)+alpha3*np.sin(2*np.pi*60*t*3+des3)+alpha5*np.sin(2*np.pi*60*t*5+des5)+alpha7*np.sin(2*np.pi*60*t*7+des7))
        x_ih.append(list(f_ih))

    if time==False:
      return x_ih
    else:
      return x_ih , list(t)

def interruption (cantidad_datos,time=False):
    """
    Generamos una interrupcion

    """

    x_i=[]
    t = np.linspace(0, 1/6, int(1/6*2000))

    for i in range (0, cantidad_datos):
        # caracteristicas sag y de la onda
        alpha = rd.uniform(0.9,1) #amplitud del sag norma IEEE
        duracion = rd.uniform(1/50, 1/5)
        t_1 = rd.uniform(0, 1/7.5-duracion)
        t_2 = t_1+duracion # el valor final depende de la duración
        desfase = rd.uniform (0, 2*np.pi) #desfase de la onda

        #resultado: onda con sag y guardamos en el dict
        f_i = (1-alpha*(u(t-t_1)-u(t-t_2)))*np.sin(2*np.pi*60*t+desfase)
        x_i.append(list(f_i))
    if time==False:
      return x_i
    else:
      return x_i , list(t)
def sag_harmonic (cantidad_datos,time=False):
    """
    Generamos sag con armonicos

    """
    x_hsa=[]
    t = np.linspace(0, 1/6, int(1/6*2000))


    for i in range (0, cantidad_datos):
        alpha = rd.uniform(0.1, 0.9) #amplitud del sag norma IEEE
        duracion = rd.uniform(1/60, 1/5)
        t_1 = rd.uniform(0, 1/7.5-duracion)
        t_2 = t_1+duracion # el valor final depende de la duración

        des=rd.uniform (0, 2*np.pi)
        alpha3=rd.uniform (0.1,0.02)
        des3=rd.uniform (0, 2*np.pi)
        alpha5=rd.uniform (0.1,0.02)
        des5=rd.uniform (0, 2*np.pi)
        alpha7=rd.uniform (0.1,0.02)
        des7=rd.uniform (0, 2*np.pi)
        #resultado: onda con sag y guardamos en el dict
        f_hsa =  (1-alpha*(u(t-t_1)-u(t-t_2)))*(np.sin(2*np.pi*60*t+des)+alpha3*np.sin(2*np.pi*60*t*3+des3)+alpha5*np.sin(2*np.pi*60*t*5+des5)+alpha7*np.sin(2*np.pi*60*t*7+des7))
        x_hsa.append(list(f_hsa))

    if time==False:
      return x_hsa
    else:
      return x_hsa , list(t)
def sag (cantidad_datos,time=False):
    """
    Generamos sag
    """

    x_sa=[]
    t = np.linspace(0, 1/6, int(1/6*2000))
#   ///////datos necesarios para el df/////

    for i in range (0, cantidad_datos):
        # caracteristicas sag y de la onda
        alpha = rd.uniform(0.1, 0.9) #amplitud del sag norma IEEE
        duracion = rd.uniform(1/60, 1/5)
        t_1 = rd.uniform(0, 1/7.5-duracion)
        t_2 = t_1+duracion # el valor final depende de la duración
        desfase = rd.uniform (0, 2*np.pi) #desfase de la onda

        #resultado: onda con sag y guardamos en el dict
        f_sa= (1-alpha*(u(t-t_1)-u(t-t_2)))*np.sin(2*np.pi*60*t+desfase)
        x_sa.append(list(f_sa))
    if time==False:
      return x_sa
    else:
      return x_sa , list(t)
def harmonic (cantidad_datos,time=False):
    """
    Generamos armonicos

    """
    x_h=[]
    t = np.linspace(0, 1/6, int(1/6*2000))

    for i in range (0, cantidad_datos):
        des=rd.uniform (0, 2*np.pi)
        alpha3=rd.uniform (0.1,0.02)
        des3=rd.uniform (0, 2*np.pi)
        alpha5=rd.uniform (0.1,0.02)
        des5=rd.uniform (0, 2*np.pi)
        alpha7=rd.uniform (0.1,0.02)
        des7=rd.uniform (0, 2*np.pi)
        #resultado: onda con sag y guardamos en el dict
        f_h = np.sin(2*np.pi*60*t+des)+alpha3*np.sin(2*np.pi*60*t*3+des3)+alpha5*np.sin(2*np.pi*60*t*5+des5)+alpha7*np.sin(2*np.pi*60*t*7+des7)
        x_h.append(list(f_h))
    if time==False:
      return x_h
    else:
      return x_h , list(t)
def oscillatory_transient (cantidad_datos,time=False):
    """
    Generamos transitorios oscilatorios

    """
    x_ot=[]
    t = np.linspace(0, 1/6, int(1/6*2000))
    for i in range (0, cantidad_datos):
        alpha=rd.uniform (0.1,0.8)
        tao=rd.uniform (8/1000,40/1000)
        delta=rd.uniform (0.5/60,3/60)
        t_1 = rd.uniform(0, 1/7.5-delta)
        t_2=delta+t_1
        desfase = rd.uniform (0, 2*np.pi) #desfase de la onda
        fn=rd.uniform (300, 900)
        #resultado: onda con sag y guardamos en el dict
        f_ot = np.sin(2*np.pi*60*t+desfase)+alpha*np.exp(-(t-t_1)/tao)*((u(t-t_1)-u(t-t_2)))*np.sin(2*np.pi*t*fn)
        x_ot.append(list(f_ot))
    if time==False:
      return x_ot
    else:
      return x_ot , list(t)


def flicker (cantidad_datos,time=False):
    """
    Generamos flicker

    """
    x_f=[]
    t = np.linspace(0, 1/6, int(1/6*2000))
    for i in range (0, cantidad_datos):
        # caracteristicas sag y de la onda
        alpha = rd.uniform(0.9, 1) #amplitud del sag norma IEEE
        alpha2 = rd.uniform(0.9, 1) #amplitud del sag norma IEEE
        alpha3 = rd.uniform(0.9, 1) #amplitud del sag norma IEEE
        alpha4 = rd.uniform(0.9, 1) #amplitud del sag norma IEEE
        desfase = rd.uniform (0, 2*np.pi) #desfase de la onda
        desfase2 = rd.uniform (0, 2*np.pi) #desfase de la onda
        desfase3 = rd.uniform (0, 2*np.pi) #desfase de la onda
        desfase4 = rd.uniform (0, 2*np.pi) #desfase de la onda
        #resultado: onda con sag y guardamos en el dict
        f_f = (alpha)*np.sin(2*np.pi*60*t+desfase)+(alpha4)*np.sin(2*np.pi*60*4*t+desfase2)+(alpha3)*np.sin(2*np.pi*60*3*t+desfase3)+(alpha2)*np.sin(2*np.pi*60*4*t+desfase4)
        x_f.append(list(f_f))
    if time==False:
      return x_f
    else:
      return x_f , list(t)
def notch (cantidad_datos,time=False):
    """
    Generamos Notch

    """
    w = 2*np.pi*60
    t = np.linspace(0, 1/6, int(1/6*2000))
#   ///////datos necesarios para el df/////
    x_no=[]
    for i in range (cantidad_datos):
      k = rd.uniform(0.1,0.4)
      desfase = rd.uniform (0, 2*np.pi)
      desfase2 = rd.uniform (0, 2*np.pi)
      t2 = rd.uniform(1/60*0.009, 0.5*1/60)
      duracion = rd.uniform(0.01*1/60, 0.05*1/60)
      t1 = t2-duracion
      # ciclo for para la sumatoria de la formula
      sumatoria = 0
      for n in range (0,10):
          sumatoria+= k*(u(t-(t1+0.02*n))-u(t-(t2+0.02*n)))

      f_no = np.sin(w*t+desfase)- np.sign(np.sin(w*t+desfase2))*sumatoria
      x_no.append(list(f_no))
    if time==False:
      return x_no
    else:
      return x_no , list(t)

x_no=notch(2)
plt.plot(x_no[0])
plt.show()
plt.plot(x_no[1])
plt.show()

"""Grafiquemos para probar las funciones"""

x=[]
x.append(normal(1))
x.append(swell_harmonic(1))
x.append(swell(1))
x.append(interruption_harmonic(1))
x.append(interruption(1))
x.append(sag_harmonic(1))
x.append(sag(1))
x.append(harmonic(1))
x.append(oscillatory_transient(1))
x.append(flicker(1))
for i in range (len(x)):
  plt.plot(x[i][0])
  plt.show()

"""Arreglamos la base de datos"""

def data(numb):
  """
  Esta funcion crea numb vectores de cada distorsion de la calidad de la energia
  ademas de otro para una onda normal.

  Siendo asi el vector y de clasificacion:
  [1,0,0,0,0,0,0,0,0,0,0] ----------------------> Onda normal
  [0,1,0,0,0,0,0,0,0,0,0] ----------------------> Onda con swell y armonico
  [0,0,1,0,0,0,0,0,0,0,0] ----------------------> Onda con swell
  [0,0,0,1,0,0,0,0,0,0,0] ----------------------> Onda con interrupcion y armonico
  [0,0,0,0,1,0,0,0,0,0,0] ----------------------> Onda con interrupcion
  [0,0,0,0,0,1,0,0,0,0,0] ----------------------> Onda con sag y armonico
  [0,0,0,0,0,0,1,0,0,0,0] ----------------------> Onda con sag
  [0,0,0,0,0,0,0,1,0,0,0] ----------------------> Onda con armonico
  [0,0,0,0,0,0,0,0,1,0,0] ----------------------> Onda con transitorio oscilatorio
  [0,0,0,0,0,0,0,0,0,1,0] ----------------------> Onda con flicker
  [0,0,0,0,0,0,0,0,0,0,1] ----------------------> Onda con notch
  """
  dt_x=[]
  dt_y=[]
  d_normal=normal(numb)
  d_swell_harmonic=swell_harmonic(numb)
  d_swell=swell(numb)
  d_interruption_harmonic=interruption_harmonic(numb)
  d_interruption=interruption(numb)
  d_sag_harmonic=sag_harmonic(numb)
  d_sag=sag(numb)
  d_harmonic=harmonic(numb)
  d_oscillatory_transient=oscillatory_transient(numb)
  d_flicker=flicker(numb)
  d_notch=notch(numb)
  for i in range (numb):
    dt_x.append(d_normal[i])
    dt_x.append(d_swell_harmonic[i])
    dt_x.append(d_swell[i])
    dt_x.append(d_interruption_harmonic[i])
    dt_x.append(d_interruption[i])
    dt_x.append(d_sag_harmonic[i])
    dt_x.append(d_sag[i])
    dt_x.append(d_harmonic[i])
    dt_x.append(d_oscillatory_transient[i])
    dt_x.append(d_flicker[i])
    dt_x.append(d_notch[i])

    dt_y.append([1,0,0,0,0,0,0,0,0,0,0])
    dt_y.append([0,1,0,0,0,0,0,0,0,0,0])
    dt_y.append([0,0,1,0,0,0,0,0,0,0,0])
    dt_y.append([0,0,0,1,0,0,0,0,0,0,0])
    dt_y.append([0,0,0,0,1,0,0,0,0,0,0])
    dt_y.append([0,0,0,0,0,1,0,0,0,0,0])
    dt_y.append([0,0,0,0,0,0,1,0,0,0,0])
    dt_y.append([0,0,0,0,0,0,0,1,0,0,0])
    dt_y.append([0,0,0,0,0,0,0,0,1,0,0])
    dt_y.append([0,0,0,0,0,0,0,0,0,1,0])
    dt_y.append([0,0,0,0,0,0,0,0,0,0,1])
  return dt_x , dt_y

"""Probamos"""

x_train , y_train =data(1)

for i in range(len(x_train)):
  plt.plot(x_train[i])
  plt.show()

plt.show()
print(y_train)

import pywt
def data_wavelet(x_t):
  wdata=[]
  w = pywt.Wavelet("db10")
  for i in range(len(x_t)):

    wav=list(pywt.wavedec(x_t[i], w, level=4))

    x=[]
    for z in range(len(wav)):
      for j in wav[z]:
        x.append(j)
    wdata.append(x)

  return wdata

w_data=data_wavelet(x_train)

print(len(w_data[0]))

"""Hacemos una base de datos de entrenamiento de 10000 vectores y otra de 10000 para testeo."""

x_train , y_train =data(10000)
w_train=data_wavelet(x_train)
del x_train

print(type(w_train[0]))

from tensorflow.keras import utils
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense , Activation
y_trainOHE = y_train
nb_classes = len(y_train[0])
input_dim=len(w_train[0])
model= Sequential ([
                    Dense(32,input_shape=(input_dim,)),
                    Activation("tanh"),
                    Dense(nb_classes),
                    Activation("softmax"),
                    ])
model.summary()

model.compile(loss="categorical_crossentropy",optimizer="sgd")
from tensorflow.keras import optimizers
sgd=tf.keras.optimizers.experimental.SGD(
    learning_rate=0.01,
    momentum=0.0,
    weight_decay=1e-6,
    clipnorm=None,
    clipvalue=None,
    global_clipnorm=None,
    use_ema=False,
    ema_momentum=0.99,
    ema_overwrite_frequency=None,
    jit_compile=True,
    nesterov=True
)
model.compile(loss="categorical_crossentropy",optimizer=sgd)
"Entrenamos el modelo "

model.train_on_batch(w_train,y_trainOHE)

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, LSTM

model.compile (
    loss='mean_squared_error',
    optimizer=tf.keras.optimizers.Adam(0.001))

model.fit(x =w_train,y=y_trainOHE)

x_test , y_test =data(10000)
w_test=data_wavelet(x_test)
del x_test
history = model.fit(w_train,y_train, epochs=30, validation_data = [w_test, y_test])

from sklearn.metrics import confusion_matrix
y_prediction = model.predict(w_test)
y_prediction1 = np.argmax (y_prediction, axis = 1)
y_test1=np.argmax(y_test, axis=1)
# porcentaje de la matriz de confusión
result = confusion_matrix(y_test1, y_prediction1 )
print(result)

print(len(result))

from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay
disp = ConfusionMatrixDisplay(confusion_matrix=result
 , display_labels = ["Normal","Swell&Harm","Swell","Inter&Harm","Inter",
                     "Sag&Har","Sag","Arm","Transi","Flick","Notch"])
disp.plot()